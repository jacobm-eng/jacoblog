<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta property="og:image" content="http://jacoblog.com/go-game.png">
  <meta name="twitter:card" content="Go game screenshot.">
  <title>Jacoblog</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <!-- Sidebar / Identity Block -->
  <aside class="sidebar">
    <h2>Jacob Mages-Haskins</h2>
    <h3>Principal Software Engineer</h3>
    <p>Contrast Security, Inc.</p>

    <p><a href="mailto:jacobmages-haskins@outlook.com">jacobmages-haskins@outlook.com</a></p>
    <p><a href="https://www.linkedin.com/in/jacob-haskins/" target="_blank">LinkedIn Profile</a></p>

    <p style="margin-top: 2rem; font-style: italic;">
      Notice:<br />
      This is my personal technical blog. Any views expressed herein are my own and not representative of my employer.
    </p>

    <p>
      <a href="index.html">Home</a>
    </p>

  </aside>

  <!-- Main Content Area -->
  <main class="main">
  <h1>I Rebuilt My AI Coding Stack</h1>
  <p><i>December 23, 2025</i></p>
  <p>The week before Christmas is always a little slower at work; so, I took the opportunity to rebuild my AI coding stack at work.  I've been reading and hearing about this tool and that; so, I took the time to hook them all together.  No one directed me to use specifically this setup, but I tried it and liked it.</p>
  <h3>Core Constraints</h3>
  <p>We work on Macs, so all code snippets in prompts are in bash.  I use zsh and iTerm2 for my shell (I like the tabbed terminal panes).  I also prefer Homebrew for installing tools when possible.</p>
  <p>The core coding agent is Claude Code running Claude Sonnet 4.5 as the LLM.  This means that all my custom slash commands are setup for Claude to use.  I turned the tool chain into 3 slash commands - 1 that sets up everything as an interactive prompt, another to make Claude act as a planning agent, and a 3rd to start multiple Claude Code sessions in parallel as coding agents.</p>
  <p>I also setup the GitHub Copliot CLI, defaulted to the grok-code-fast-1 model, to be available for Claude Code to call as an oracle if it gets stuck.  I've seen other devs setup their own oracle LLM options, but this is one that I have available through our corporate accounts.</p>
  <p>For source code management, my setup uses Git and GitHub.  Claude uses the GitHub CLI tool for GitHub-specific interactions.</p>
  <h3>Prereqs</h3>
  <p>My setup slash command checks that some CLI tools are installed: ripgrep, fzf, lazygit, and ast-grep.  It also installs some language runtime tools that other tools will depend on: uv, go, rust+cargo, and bun.</p>
  <h3>Plan</h3>
  <p>My plan and work slash commands follow the basics of the software development process.</p>
  <p>When I invoke the plan command, I give it either a Jira ticket or a feature description and Claude makes the Jira ticket for me.  Both situations end up using the Atlassian MCP server to interact with Jira: <a href="https://github.com/atlassian/atlassian-mcp-server" target="_blank">https://github.com/atlassian/atlassian-mcp-server</a></p>
  <p>Then it uses the Superpowers skills (< href="https://github.com/obra/superpowers" target="_blank">https://github.com/obra/superpowers</a>) to brainstorm with me and interview about the feature.</p>
  <p>That expanded feature description gets handed off to Every's Compound Engineering plugin (<a href="https://github.com/EveryInc/compound-engineering-plugin/tree/main/plugins/compound-engineering" target="_blank">https://github.com/EveryInc/compound-engineering-plugin/tree/main/plugins/compound-engineering</a>) to be turned into a full-fledged development plan.  Read more about <a href="https://every.to/chain-of-thought/compound-engineering-how-every-codes-with-agents" target="_blank">Every's Compound Engineering philosophy</a>.</p>
  <p>Claude breaks that plan into beads (<a href="https://github.com/steveyegge/beads/tree/main" target="_blank">https://github.com/steveyegge/beads/tree/main<a>).  I like tracking those beads with Chris Edward's Abacus tool (<a href="https://github.com/ChrisEdwards/abacus" target="_blank">https://github.com/ChrisEdwards/abacus</a>).</p>
  <p>As a final bit of setup, the plan command makes a Git feature branch for this Jira ticket and records any learnings from this planning session in a file that it can read later to augment its context.</p>
  <h3>Work</h3>
  <p>I started Claude Code instances running with the work slash command.  They corrdinated with each other through beads and reserved files (like semaphore-style locking) with mcp_agent_mail (<a href="https://github.com/Dicklesworthstone/mcp_agent_mail" target="_blank">https://github.com/Dicklesworthstone/mcp_agent_mail</a>).  This did a fairly good job at keeping them from colliding, but it opened them up to work on beads in parallel when they became unblocked.  Speaking of which, the agents would run beadsviewer (<a href="https://github.com/Dicklesworthstone/beads_viewer" target="_blank">https://github.com/Dicklesworthstone/beads_viewer</a>) with the "--robot-plan" argument to get a JSON report on what is the highest priority, unblocked bead to work on next.</p>
  <p>Each work agent builds its initial context by reading the plan, using coding_agent_session_search (<a href="https://github.com/Dicklesworthstone/coding_agent_session_search" target="_blank">https://github.com/Dicklesworthstone/coding_agent_session_search</a>) and cass_memory_system (<a href="https://github.com/Dicklesworthstone/cass_memory_system" target="_blank">https://github.com/Dicklesworthstone/cass_memory_system</a>).  It also has the Context7 mcp server (<a href="https://context7.com/" target="_blank">https://context7.com/</a>) available to look up documentation.  And, it reviews the content in its learnings document for the project.</p>
  <p>Once it's context is loaded up and its found a bead to work on, it goes back to Superpowers for Test Driven Development - style execution.<p>
  <p>It reviews its work with multiple review tools: Claude's built in /review and /security-review slash commands, ultimate_bug_scanner (<a href="https://github.com/Dicklesworthstone/ultimate_bug_scanner" target="_blank">https://github.com/Dicklesworthstone/ultimate_bug_scanner<a>), the Superpowers review, and Compound Engineering's review.  The point of all these review tools isn't to be perfect, but to catch as much stupid stuff as possible before a human needs to look at the code.</p>
  <p>Last, it makes a PR, pushes everything up to the remote git repo, and records any learningsf.</p>
  <h3>Results</h3>  
  <p>The work agents aren't fully autonomous.  They need bash commands approved for running, cajouling, answers to clarifying questions, or help when stuck.  But they are really capable.  I tested this setup with a feature idea I had this morning.  In 2023, it probably would have taken me a week to code by hand with multiple rounds of revisions from human code reviews.  This AI coding setup did that work in roughly 40 minutes, and it was approved by human reviewers with no change requests.</p>
  <p>I can't wait to see what innovations 2026 brings!</p>
  </main>

  <!-- Optional: Giscus Comment Section -->
  <!--
  <script src="https://giscus.app/client.js"
    data-repo="yourusername/jacoblog"
    data-repo-id="REPO_ID"
    data-category="Post Comments"
    data-category-id="CATEGORY_ID"
    data-mapping="pathname"
    data-reactions-enabled="1"
    data-theme="light"
    crossorigin="anonymous"
    async>
  </script>
  -->
</body>
</html>
